#### Trevor Johnson
##### CS410P Winter 2020
##### Hw 1 Submission

The purpose of this project was to write an introductory rust program that calculates the value of the expression (x^y) mod z, where x, y and z are given command line arguments. To start I generated a new project in rust using `cargo new modexp --bin` to create a new project named `modexp`. This created a source directory named `src` and a `Cargo.Toml` manifest. Inside the `src` directory was a file named `main.rs`. This is the `main` function of the program, and is where the logic of my mod exp calculator lives. This file takes 3 command line arguments (base, exp, m), parses them for their `u64` values and returns the results of the expression (base^exp) mod m. Negative numbers given will force the process to `exit(1)` with an error message that gives an example of how to properly use the function, and the argument types it is expecting. This same error handling occurs for if the user forgot an argument as the vector that holds the arguments is checked to verify a minimun of 3 arguments given.

Overall the project went smoothly and many of Rust's more useful features are starting to become apparent. The variable type system strictness took some getting used to, however I can see how this forces the programmer to follow better coding patterns and solves problems at compile time rather than run time. That being said it is also nice that there are interpreted types for declaration for variables that are an obvious type.

I tested my work by writing and running a test function defined in `main.rs` named `modexp_test1`. I then ran `cargo test` on my project and found the test passed. In `modexp_test1`, I included tests to check that given the values *2*, *20* and *17*, the function returned *16* as specified in the assignment instructions. I also tested values that result in an even 0 division to verify the function returned 0 for modular division. Last I tested a value that I thought would break the `u64` size argument type and expected this test to panic, however it did not and returned the correct value per those inputs. I also added error checking to the `main.rs` to `exit(1)` if to few arguments were given.